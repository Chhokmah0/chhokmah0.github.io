---
title: 高性能计算-第四章-编译
date: 2024-12-01 22:31:00 +0800
categories: [笔记，高性能计算]
tags: [hpc]     # TAG names should always be lowercase
math: true
---
## 序 - 编译

学习汇编语言的好处并不仅仅是会用它来写程序，更重要的是能够理解编译后的代码在执行时发生了什么，以及它的性能。

只有在很少的情况下，我们才真的需要手写汇编来获得最优的性能，但实际上大多是情况下编译器就能够产生接近于最优的代码。
当编译器没这么做的时候，通常是因为程序员对问题了解得更多，而编译器却不能把这些额外的信息从源码当中推断出来。

在这一章节，我们将会讨论如何指导编译器完成我们想要的工作，并且收集一些有用的信息方便后续的优化。

## 一 - 编译的阶段

先来了解一下如何将一个 c 语言程序编译成可执行文件：

1. **预处理**：展开宏、将导入的头文件的源码拉入到源码里、删除掉代码中的注释。`gcc -E source.c`
2. **编译**：解析源码、检查语法错误、将源码转化为中间表示、性能优化、将中间表示翻译成汇编语言：`gcc -S file.c`
3. **汇编**：将汇编语言转化为机器码，但是将一些外部函数的调用暂时用占位符替代（比方说 `printf` 函数）：`gcc -c file.c`（返回一个 `.o` 文件，表示 `object file`）
4. **链接**：最后解析函数调用的实际地址，并生成可执行二进制文件：`gcc -o binary file.c`

在每一个阶段都有可能提高程序的性能。

### 过程间优化

考虑最后一个阶段，链接，毕竟一个一个编译文件然后把它们链接到一起既简单又快速。你还能并行处理这个，还能保存中间结果。

这还为代码提供了分发的能力，也即 _库文件_，可以是静态的或者是动态的：

- 静态链接库只是一些预编译的**目标文件**的集合。它会被编译器拿来和其它源码一起生成一个可执行文件，就像平时使用的一样。
- 动态链接库，或者共享链接库。这些东西是一些预编译的**可执行文件**，并包含一些额外的信息，比方说它们的可调用函数的地址，并在运行时动态地解析出来。就像它的名字一样，这个链接库内部的二进制可以在不同的程序当中共享。

使用静态链接库的优点在于，它包含了比库函数签名更多的上下文信息，从而可以执行不同的过程间优化，比方说函数内联或者死代码消除。
为了强制链接器查找并使用静态库，可以传入 `-static` 选项。

这个过程被称为 _链接时优化（Link-time optimization, LTO）_。
现代编译器会在目标文件中存储某种形式的中间表示，编译器可以利用这些做一些简单的优化。
同时也允许了在一个程序中可以使用不同的编译语言，如果它们的编译器使用相同的中间表示，甚至可以跨语言进行优化。

LTO 是一个相对较新的特性（GCC 在 2014 年左右实现），离达到完美的程度还很远。
在 C 或 C++ 中，确保在分离编译时不会有性能损失的方式是创建一个 _只有头文件的库（hearder-only library, .hpp)_，不带任何 .cpp 文件。
顾名思义，它们在头文件中包含了所有的函数定义。通过引入它们，编译器可以使用所有的优化。
尽管每次编译都需要重新编译库的代码，但是这种方式可以让编译器获得完全的控制权，并确保没有性能损失。

### 观察输出

观察每个阶段的输出可以获得一些有用的见解。

通过传递 `-S` 标志给编译器（在 rust 中，建议使用 `cargo-show-asm` 来查看汇编代码），可以生成一个人类可读的汇编文件 `*.s`。如果你传入 `-fverbose-asm`，该文件还将包含源代码行号和使用的变量的信息。
如果它只是一个非常小的代码块，而且咱还是个懒狗。那么可以使用 `Compiler Explorer`。
这是一个非常方便的在线工具，可以将源代码转换为汇编代码，突出显示逻辑 asm 块，包含一个小型 x86 指令集参考，还提供大量其他编译器、目标和语言的选择。

除了汇编以外，另外一个有用的抽象表示是 _中间表示（intermediate representation, IR）_。
IR 定义了计算流本身，并且很少依赖于不同架构本身的特性，如寄存器的数量或者特定的指令集。
检查这些代码可以深入了解编译器如何看待您的程序，但这超出了本书的范围。

在本章中，我们将主要使用 GCC（当然我会尝试着加入 Rust 的 rustc），但必要时也会尝试为 Clang 复刻示例。
在大多数情况下，这两个编译器在很大程度上是相互兼容的，只是在一些优化标志和次要的语法细节上有所不同。

## 二 - 标志和目标

想要高性能的第一步是要求编译器编译高性能程序。这可以通过使用几百个不同的编译器选项、属性和参数来完成。

### 优化等级

在 GCC 中，有四个**半**不同的优化等级：

- `-O0`：默认选项，不进行任何优化。（不过反过来讲，它优化了编译时长）
- `-O1`：做了一些“唾手可得”的优化。几乎不影响编译时间。
- `-O2`：启用所有已知的几乎没有负面影响的优化。需要合理的时长来完成（这是大多数项目用于生产构建的方法）。
- `-O3`：进行非常积极的优化。几乎支持所有在 GCC 中实现的正确优化。
- `-Ofast`：做 `-O3` 做了的事情，并且还增加了一些优化标志。这些标志可能不会遵从一些严格的标准，但这些标准在大多数应用程序中不是很重要（比方说，浮点运算可能被重新排列，导致结果中产生几位的偏差）。

（题外话：在 rust 中，优化等级对应着 `opt-level`，具体的可以查看 Cargo Book 的 Profiles 章节。）

还有许多其他的优化标志，即使是在 `-Ofast` 中也没有启用。因为它们是非常情境化的，默认启用它们更有可能损害而不是提高性能——我们将在下一节中讨论其中的一些。

### 指定目标

接下来我们可以尝试告诉编译器，这段代码会在什么机器上运行。当然，指定的平台越具体越好。默认上，编译器会生成一个可以在比较新（2000 年后）的 x86 CPU 上运行的二进制文件。
缩小范围的最简单方法是传递 `-march` 标志来指定微架构：`-march=haswell`。
如果我们在同一台计算机上编译和运行源码，则可以使用 `-march=native` 进行自动检测。
