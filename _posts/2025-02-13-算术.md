---
title: 高性能计算-第六章-算术
date: 2025-2-13 12:00:00 +0800
categories: [笔记，高性能计算]
tags: [高性能计算]     # TAG names should always be lowercase
math: true
---
## 序 - 算术

正如我们在本书中提到的那样，了解指令集中的冷门指令可能会带来丰厚的回报，尤其是在 下6 这样的 CISC 平台上，目前它有大约 1000 到 4000 条不同的指令。

这些指令大多与算术相关，要想要高效地使用它们来优化算术操作，需要大量的知识、技能和创造力。因此，在本章中，我们将讨论数字表示及其在数值算法中的应用。

## 一 - 浮点数

使用浮点数来做算术的人，在对浮点数的了解程度上大概构成一个钟形曲线：

- 新手程序员会到处使用浮点数，就好像它是一个具有无限精度的神奇的数据类型一样。
- 然后，程序员发现 `0.1 + 0.2 != 0.3` 或者其它的一些奇怪现象。于是开始认为浮点数在每次计算中都会有随机的误差，而在很长时间内都拒绝了解浮点数的真正结构。
- 然后他们终于振作起来，阅读 IEEE-754 浮点数如何工作的规范，并开始适当地使用它们。

不幸的是，有太多程序员停留在阶段 2 了，对浮点运算产生了各种各样的误解——认为它从根本上说是不精确和不稳定的，而且比整数运算慢。

但这些都只是传言而已。由于有专门的指令，浮点运算通常比整数运算快。而且实数的表示是完全标准化的，在舍入方面遵循简单而确定的规则，允许我们可信地处理计算误差。

事实上，浮点数可靠到有一些高级编程语言根本没有整数类型，比方说 JavaScript，在里面只有 `number` 类型，底层是一个 64-bit 的 `double`。根据浮点数的计算规则，实际上所有在 `-2^53` 到 `2^53` 内的整数都可以被精确表示。所以从程序员的角度看，基本上没有什么使用整数类型的必要。

一个值得注意的例外是，当你需要对数字做逐位操作时，浮点数类型是不支持这样的操作的。在这种情况下，它们需要被转换为整数，这在支持 Javascript 的浏览器中使用得过于频繁，以至于 arm 添加了一个特殊的“FJCVTZS”指令，它代表“浮点 Javascript 转换为带符号的定点数（整数），并向零舍入”（Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero）——这是一个有趣的软件-硬件反馈循环的例子。

不过，只要你不是专门用实数来行来模拟整数运算的 JavaScript 程序员，你大概率还是需要了解一下浮点数的运算规则。

### 实数的表示

如果我们需要处理实数（非整数），我们有一些可选的实现方法。在讨论浮点数前，我们可以先讨论一下可用的替代方案，以及其背后的动机——不然总会用不想用浮点数的人的。

#### 符号表示

第一种、同时也是最麻烦的方法是不存储结果值本身，而是存储它们的代数表达式。

有一个简单的例子。在一些应用中，比方说计算几何，除了加减乘除之外，还需要精确地进行除法，以生成一个有理数。我们可以用两个整数的比率精确表示它：

```cpp
struct r {
    int x, y;
};

r operator+(r a, r b) { return {a.x * b.y + a.y * b.x, a.y * b.y}; }
r operator*(r a, r b) { return {a.x * b.x, a.y * b.y}; }
r operator/(r a, r b) { return {a.x * b.x, a.y * b.y}; }
bool operator<(r a, r b) { return a.x * b.y < b.x * a.y; }
// ...and so on, you get the idea
```

这个分数应该是不可约的，这样就可以产生一个唯一的表示：

```cpp
struct r {
    int x, y;
    r(int x, int y) : x(x), y(y) {
        if (y < 0)
            x = -x, y = -y;
        int g = gcd(x, y);
        x /= g;
        y /= g;
    }
};
```

这就是计算机代数系统（如 WolframAlpha 或 SageMath）的工作原理：它们只对符号表达式进行操作，避免将任何东西计算为实数。

使用这种方法，我们可以获得绝对的精度，当我们只需要有理数的时候，它表现得非常好。但这需要很大的计算成本，因为在通常情况下，我们是需要以某种方式存储整个操作历史，并在每次执行新操作时都考虑它——随着操作历史的增长，这很快变得不可行。

#### 定点数

另一种方法是坚持使用整数，但将它们视为乘了一个固定的常数。这在本质上和为了更精确地测量而改变了测量单位是一样的。

由于有些值不能精确地表示，这使得计算不精确：我们需要将结果四舍五入到最接近的可表示值。

这种方法通常用于财务软件，在这些软件中，我们确实需要一种直接的方法来管理舍入误差，以便最终数字相加。例如，NASDAQ 在其股票清单中使用 $\frac{1}{10000}$ 美元作为基本单位，这意味着在所有交易中，逗号后的精确值为 4 位。

```cpp
struct money {
    uint v; // 1/10000th of a dollar
};

std::string to_string(money) {
    return std::format("${0}.{1:04d}", v / 10000, v % 10000);
}

money operator*(money x, money y) { return {x.v * y.v / 10000}; }
```

除了引入了舍入误差之外，另一个问题是当常数设置错误时，整个定点数很容易变得没有用处。如果正在处理的数字太大，则内部的整数值将溢出，如果数字太小，则会被舍入为零。有趣的是，当 NASDAQ 的股价接近 $\frac{2^{32} - 1}{10000} = 429,496.7295$ 时，前一种情况曾经成为纳斯达克的一个问题，无法用无符号 32 位整数容纳。

这个问题使得定点数从根本上不适合需要同时使用小数字和大数字的应用，例如，计算某些物理方程 $E=mc^2$。$m$ 通常小到原子的量级（$1.67 \cdot 10^{-27}$ kg），而 $c$ 却是光速（$3 \cdot 10^9$ m/s）。

#### 浮点数

在大多数数值应用中，我们主要关心的是相对误差。我们希望我们的计算结果与事实的差异不超过 0.01%，而并不关心 0.01% 具体是多少。

浮点数通过存储一定数量的最高有效数字和数字的数量级来解决这个问题。更准确地说，它们用一个整数（称为有效数或尾数）表示，并使用固定基数的指数（通常是 2 或 10）进行缩放。例如:

$$
1.2345=\underbrace{12345}_{有效数}\times {\underbrace{10}_{基数}}^{\overbrace{-4}^{指数}}
$$

计算机只在固定长度的二进制字节上操作，所以为硬件设计浮点数标准时，我们希望使用固定的二进制格式，其中一些位专用于有效数（用于更高的精度），一些专用于指数（用于更大的范围）。

例如给一种非常基础的实现：

```cpp
struct fp {
    int m; // mantissa
    int e; // exponent
};
```

这样我们既可以使用 $\pm m\times 2^e$ 的格式来表示，其中 $m$ 和 $e$ 都是有界并且可能为负的整数——分别对应负数和小数。这些数字的分布非常不均匀，在 $[0,1)$ 之间的数字数量和 $[1, +\infty)$ 之间的数字数量几乎一样。

注意到在这种表示下，数字的表示并不是唯一的，例如，有：

$$
1\tims 2^0 = 2 \times 2^{-1} = 256 \times 2^{-8} = \dots
$$

这对于某些应用（例如比较或者 hash）可能会有问题。为了解决这个问题，我们可以使用某种约定对这些表示进行规范化。在十进制中，标准形式总是在第一位非零的数字（6.022e23）后面加小数点，对于二进制，我们也可以这样做：

$$
42 = 10101_2 = 1.0101_2 \times 2^5
$$

注意到，根据这个规则，有效数的第一位总是1。显式地存储它是多余的，所以我们就假装它在那里，只存储其他的位。这样有效数对应于 $[0,1)$ 范围内的某个有理数，也是其被称为尾数的原因。可表示数的集合现在大致是：

$$
\{\pm (1+m)2^e | m = \frac{x}{2^{32}}, x \in [0, 2^{32}) \}
$$

$m$ 现在又变成非负值了，所以为了表示负数，我们还需要增加一个符号位：

```cpp
struct fp {
    bool s;     // sign: "0" for "+", "1" for "-" 
    unsigned m; // mantissa
    int e;      // exponent
};
```

现在，让我们尝试使用这个浮点数来实现一些算术运算——例如乘法。使用新的形式，结果应该是：

$$
\begin{aligned}
c =& a \cdot b \\
=& (s_a(1+m_a)2^{e_a})(s_b(1+m_b)2^{e_b}) \\
=& \underbrace{s_a s_b}_{s_c} \cdot (1+ \underbrace{m_a + m_b + m_a m_b}_{m_c}) \cdot 2^{\overbrace{e_a + e_b}^{e_c}}
\end{aligned}
$$

这样的分组计算看上去很容易，但有一些小细节：

- 新的尾数现在在 $[0,3)$ 的范围内。我们需要检查它是否大于 1，并通过以下公式将其规范化表示：

$$
1+m = (1+1) + (m -1) = (1 + \frac{m-1}{2})\cdot 2
$$

- 由于精度不足，结果数字可能（且很可能）无法精确表示。我们需要两倍的比特位数来处理 $m_a m_b$ 项，而我们能做的最好事情是将其舍入到最接近的可表示数字。

由于我们需要一些额外的位来正确处理尾数溢出问题，因此我们将从 $m$ 中保留一位，从而将其限制在 $[0, 2^{31})$ 范围内。

```cpp
fp operator*(fp a, fp b) {
    fp c;
    c.s = a.s ^ b.s;
    c.e = a.e + b.e;
    
    uint64_t x = a.m, y = b.m; // 转换到更宽的类型
    uint64_t m = (x << 31) + (y << 31) + x * y; // 62 或 63 位的结果
    if (m & (1<<62)) { // 检查是否溢出（大于 1）
        m -= (1<<62); // m -= 1;
        m >>= 1;
        c.e++;
    }
    m += (1<<30); // 加 0.5 从而和之后的 floor 操作共同达成四舍五入的效果。
    c.m = m >> 31;
    
    return c;
}
```

许多需要更高精度的应用程序以类似的方式实现 _软件浮点运算_。但当然，我们不希望每次将两个实数相乘时都执行这段代码编译出的约 10 条指令序列，因此在现代 CPU 中，浮点运算是在硬件中实现的——由于其复杂性，通常作为单独的协处理器。

x86 的浮点单元（通常称为 x87）具有单独的寄存器及其自己的小型指令集，支持内存操作、基本算术、三角函数以及一些常见操作，如对数、指数和平方根。为了使这些操作能够正确协同工作，我们需要澄清浮点数表示的一些额外细节——这些将在下一节中讨论。
