---
title: 高性能计算-第四章-编译
date: 2025-2-05 14:10:00 +0800
categories: [笔记, 高性能计算]
tags: [高性能计算]     # TAG names should always be lowercase
math: true
---
[原文](https://en.algorithmica.org/hpc/compilation/)

## 序 - 编译

学习汇编语言的好处并不仅仅是会用它来写程序，更重要的是能够理解编译后的代码在执行时发生了什么，以及它的性能。

只有在很少的情况下，我们才真的需要手写汇编来获得最优的性能，但实际上大多是情况下编译器就能够产生接近于最优的代码。当编译器没这么做的时候，通常是因为程序员对问题了解得更多，而编译器却不能把这些额外的信息从源码当中推断出来。

在这一章节，我们将会讨论如何指导编译器完成我们想要的工作，并且收集一些有用的信息方便后续的优化。

## 一 - 编译的阶段

先来了解一下如何将一个 c 语言程序编译成可执行文件：

1. **预处理**：展开宏、将导入的头文件的源码拉入到源码里、删除掉代码中的注释。`gcc -E source.c`
2. **编译**：解析源码、检查语法错误、将源码转化为中间表示、性能优化、将中间表示翻译成汇编语言：`gcc -S file.c`
3. **汇编**：将汇编语言转化为机器码，但是将一些外部函数的调用暂时用占位符替代（比方说 `printf` 函数）：`gcc -c file.c`（返回一个 `.o` 文件，表示 `object file`）
4. **链接**：最后解析函数调用的实际地址，并生成可执行二进制文件：`gcc -o binary file.c`

在每一个阶段都有可能提高程序的性能。

### 过程间优化

考虑最后一个阶段，链接，毕竟一个一个编译文件然后把它们链接到一起既简单又快速。你还能并行处理这个，还能保存中间结果。

这还为代码提供了分发的能力，也即 _库文件_，可以是静态的或者是动态的：

- 静态链接库只是一些预编译的**目标文件**的集合。它会被编译器拿来和其它源码一起生成一个可执行文件，就像平时使用的一样。
- 动态链接库，或者共享链接库。这些东西是一些预编译的**可执行文件**，并包含一些额外的信息，比方说它们的可调用函数的地址，并在运行时动态地解析出来。就像它的名字一样，这个链接库内部的二进制可以在不同的程序当中共享。

使用静态链接库的优点在于，它包含了比库函数签名更多的上下文信息，从而可以执行不同的过程间优化，比方说函数内联或者死代码消除。为了强制链接器查找并使用静态库，可以传入 `-static` 选项。

这个过程被称为 _链接时优化（Link-time optimization, LTO）_。现代编译器会在目标文件中存储某种形式的中间表示，编译器可以利用这些做一些简单的优化。同时也允许了在一个程序中可以使用不同的编译语言，如果它们的编译器使用相同的中间表示，甚至可以跨语言进行优化。

LTO 是一个相对较新的特性（GCC 在 2014 年左右实现），离达到完美的程度还很远。在 C 或 C++ 中，确保在分离编译时不会有性能损失的方式是创建一个 _只有头文件的库（hearder-only library, .hpp)_，不带任何 .cpp 文件。顾名思义，它们在头文件中包含了所有的函数定义。通过引入它们，编译器可以使用所有的优化。尽管每次编译都需要重新编译库的代码，但是这种方式可以让编译器获得完全的控制权，并确保没有性能损失。

### 观察输出

观察每个阶段的输出可以获得一些有用的见解。

通过传递 `-S` 标志给编译器（在 rust 中，建议使用 `cargo-show-asm` 来查看汇编代码），可以生成一个人类可读的汇编文件 `*.s`。如果你传入 `-fverbose-asm`，该文件还将包含源代码行号和使用的变量的信息。如果它只是一个非常小的代码块，而且咱还是个懒狗。那么可以使用 `Compiler Explorer`。这是一个非常方便的在线工具，可以将源代码转换为汇编代码，突出显示逻辑 asm 块，包含一个小型 x86 指令集参考，还提供大量其他编译器、目标和语言的选择。

除了汇编以外，另外一个有用的抽象表示是 _中间表示（intermediate representation, IR）_。IR 定义了计算流本身，并且很少依赖于不同架构本身的特性，如寄存器的数量或者特定的指令集。检查这些代码可以深入了解编译器如何看待您的程序，但这超出了本书的范围。

在本章中，我们将主要使用 GCC（当然我会尝试着加入 Rust 的 rustc），但必要时也会尝试为 Clang 复刻示例。在大多数情况下，这两个编译器在很大程度上是相互兼容的，只是在一些优化标志和次要的语法细节上有所不同。

## 二 - 标志和目标

想要高性能的第一步是要求编译器编译高性能程序。这可以通过使用几百个不同的编译器选项、属性（attributes）和编译指示（pragmas）来完成。

### 优化等级

在 GCC 中，有四个**半**不同的优化等级：

- `-O0`：默认选项，不进行任何优化。（不过反过来讲，它优化了编译时长）
- `-O1`：做了一些“唾手可得”的优化。几乎不影响编译时间。
- `-O2`：启用所有已知的几乎没有负面影响的优化。需要合理的时长来完成（这是大多数项目用于生产构建的方法）。
- `-O3`：进行非常积极的优化。几乎支持所有在 GCC 中实现的正确优化。
- `-Ofast`：做 `-O3` 做了的事情，并且还增加了一些优化标志。这些标志可能不会遵从一些严格的标准，但这些标准在大多数应用程序中不是很重要（比方说，浮点运算可能被重新排列，导致结果中产生几位的偏差）。

（题外话：在 rust 中，优化等级对应着 `opt-level`，具体的可以查看 Cargo Book 的 Profiles 章节。）

还有许多其他的优化标志，即使是在 `-Ofast` 中也没有启用。因为它们是非常情境化的，默认启用它们更有可能损害而不是提高性能——我们将在下一节中讨论其中的一些。

### 指定目标

接下来我们可以尝试告诉编译器，这段代码会在什么机器上运行。当然，指定的平台越具体越好。默认上，编译器会生成一个可以在比较新（2000 年后）的 x86 CPU 上运行的二进制文件。缩小范围的最简单方法是传递 `-march` 标志来指定微架构：`-march=haswell`。如果我们在同一台计算机上编译和运行源码，则可以使用 `-march=native` 进行自动检测。

指令集通常是向后兼容的，因此一般情况下只需要使用最老的微体系结构就就行了。一个更有健壮性（鲁棒性）的方案是列出保证 CPU 拥有的特性：`-mavx2`，`-mpopcnt`。当我们只想针对特定的机器优化程序，二部使用任何可能在不兼容的 CPU 上导致崩溃的指令时，可以使用 `-mtune` 标志（默认情况下，`-march=x` 就已经隐含了 `-mtune`）。

这些选项也可以用编译指示来完成，当你需要优化某一个单元，而不需要优化整个项目时，可以通过这种方式来加快编译速度。

```cpp
#pragma GCC optimize("O3")
#pragma GCC target("avx2")
```

### 多版本函数

有些时候可能会需要根据特定的指令集实现特定的函数。可以使用基于属性的语法从而在编译期间自动选择基于属性的语法：

```cpp
__attribute__(( target("default") )) // fallback implementation
int popcnt(int x) {
    int s = 0;
    for (int i = 0; i < 32; i++)
        s += (x>>i&1);
    return s;
}

__attribute__(( target("popcnt") )) // used if popcnt flag is enabled
int popcnt(int x) {
    return __builtin_popcount(x);
}
```

在 Clang 中，不能使用编译指示从源代码中设置目标和优化标志，但可以像在 GCC 中一样使用属性来实现相同的功能。

## 三 - 情景优化

大多数由 `-O2` 和 `-O3` 启动的编译器优化，都保证能够提升性能，或者至少不会严重损害性能。对于没有被包含在 `-O3` 中的优化，要么不完全符合标准，要么具有高度的场景依赖性，需要程序员提供额外的输入来判断使用它们是否有益。

让我们讨论一些最常用的优化选项，这些选项我们在本书之前的内容中也已经介绍过。

### 循环展开

循环展开默认是关闭的，除非这个循环只迭代一个很小的编译期常数次--在这种情况下，循环会被展开成没有跳转的重复指令序列。可以使用 `-funroll-loops` 标志来在全局启用循环展开，它会将所有可以在编译期或者进入循环时确定循环次数的循环进行展开。

也可以使用编译标志来展开特定的循环：

```cpp
#pragma GCC unroll 4
for (int i = 0; i < n; i++) {
    // ...
}
```

循环展开会使二进制文件变大，同时可能会也可能不会使它运行得更快。所以不要狂热地使用它。

### 函数内联

内联最好留给编译器来决定，但你可以用 `inline` 关键字来影响它：

```cpp
inline int square(int x) {
    return x * x;
}
```

但是，如果编译器认为潜在的性能增益不值得，就会忽略该提示。不过你也可以通过添加 `always_inline` 属性来强制编译器进行内联：

```cpp
#define FORCE_INLINE inline __attribute__((always_inline))
```

在 rust 中则是使用 `#[inline]`，`#[inline(always)]`，`#[inline(never)]` 属性来表示内联的各种提示。

还有一个 `-finline-limit=n` 选项让你可以调节内联函数大小的阈值（根据其指令数量）。在 Clang 中，等价的选项为 `-inline-threshold`。由于 Rust 也是用 LLVM 编译，所以可以通过 `-C` 标志使用 Clang 的一些选项。

### 分支的可能性

分支的可能性可以使用 `[[likely]]` 和 `[[unlikely]]` 属性标记 if 语句或者 switch 语句：

```cpp
int factorial(int n) {
    if (n > 1) [[likely]]
        return n * factorial(n - 1);
    else [[unlikely]]
        return 1;
}
```

这是 C++20 加入的新特性，在这之前，有一个编译器内部函数可以用来包装条件表达式。在旧版 GCC 上的例子为：

```cpp
int factorial(int n) {
    if (__builtin_expect(n > 1, 1))
        return n * factorial(n - 1);
    else
        return 1;
}
```

还有很多种情况，你需要向编译器指示正确地方向。但我们在之后讨论到的时候再详细说明。

### 基于性能分析的优化（Profile-Guided Optimization）

把问题的所有元数据添加到源代码里是非常无聊的。人们在写完 C++ 后就已经开始恨 C++ 本身了，更别说做这事了。

某些优化是否有益并不是显而易见的。为了决定我们要不要使用分支重排、函数内联、循环展开，我们需要回答以下问题：

- 这个分支被选择的频率是多少？
- 这个函数多久被调用的频率是多少？
- 这个循环的平均迭代次数是多少？

幸运的是，有一种方法可以自动提供这些真实世界的信息。

_基于性能分析的优化（Profile-Guided Optimization, PGO, pogo）_ 是一种利用性能分析数据来优化性能的技术，其效果超过了仅仅通过静态分析所能达到的优化水平。简单来讲，它在程序的关键点添加计时器和计数器，在真实的数据上编译并运行程序，然后再次编译程序，但这次编译会利用测试运行中收集的额外信息来指导优化。

在现代编译器中，整个流程都是自动化的。例如，`-fprofile-generate` 标志会让 GCC 在程序中插入性能分析代码：

```terminal
g++ -fprofile-generate [其他标志] source.cc -o binary
```

在我们运行程序后（最好是在接近真实使用场景的输入上运行），它会生成一系列 `*.gcda` 文件，这些文件包含了测试运行的日志数据。之后，我们可以重新编译程序，但这次添加 `-fprofile-use` 标志：

```terminal
g++ -fprofile-use [其他标志] source.cc -o binary
```

对于大型代码库，这种方法通常可以将性能提升 10-20%，因此它常常被包含在对性能要求较高的项目的构建流程中。这也是为什么值得投入精力来编写一个可靠的基准测试代码。

## 四 - 契约式编程

在 Java 和 Rust 这种“安全”语言中，通常每种可能的操作和输入都有明确的行为定义。虽然存在一些未完全定义的细节，例如哈希表中键的顺序或者 `vector` 的增长因子，但这些通常是一些次要的实现细节，留给未来可能的性能优化。

相比之下，C 和 C++ 将 _未定义行为（undefined behavior）_ 的概念提升了一个档次。某些操作不会在编译或者运行时引发错误，但却是被禁止的——这相当于程序员和编译器的一种契约：如果发生未定义行为，编译器则被允许做任何事情，包括炸掉你的显示器或格式化你的硬盘。不过，编译器工程师们不会真的这么做。未定义行为的引入主要是为了确保没有极端情况，从而帮助编译器优化代码。

### 为什么存在未定义行为

导致未定义行为的操作主要有两种：

- 一些基本是无意间产生 bug 的操作。比方说除零、解引用空指针、读取一个没有初始化的内存。我们希望在测试期间尽快捕获这些问题，因此让它们崩溃或具有一些不确定的行为比让它们总是执行固定的回退操作（如返回零）要好。  
你可以使用 _sanitizers（消毒器）_ 来编译并运行程序，从而捕捉未定义行为。在 GCC 和 Clang 中，可以使用 `-fsanitize=undefined` 标志，一些臭名昭著的会导致 UB 的操作会在运行时被检测出来。
- 一些在不同的平台上有轻微不同结果的操作。例如，将一个大于 31 bits 的整数左移是 UB。因为这个指令在 Arm 和 x86 的 CPU 上的运行结果并不一样。如果我们认为某一种平台的行为是标准的，那么所有的程序在另一种平台上编译时就需要多花几个时钟周期去检查边际条件，所以最好还是把它们留作是未定义的。  

有时候，当某些平台的特定行为存在合理的用例时，与其称其为未定义，不如称之为 _实现定义行为（implementation-defined）_，官方标准不定义，而是由编译器自行实现。例如，对负整数进行右移操作有两种合理结果：逻辑右移（左侧补 0）和算术右移（左侧补 1）。

将某些行为指定为未定义而不是实现定义的行为也有助于编译器进行优化。考虑有符号整数溢出的情况，在大多数架构上，有符号整数溢出和无符号的工作方式一样，即 `INT_MAX + 1 == INT_MIN`。然而，根据 C++ 标准，这是未定义行为。这是有意为之：如果你禁止有符号整数溢出，那么 `(x + 1) > x` 对 `int` 总是为真，但对 `unsigned int` 不是，因为 `x + 1` 可能溢出。此时对于有符号类型，编译器就可以优化掉这种检查。

有一个更自然的例子。考虑一个由整数变量的控制循环。现代 C++ 和 Rust 等语言鼓励程序员使用无符号整数（`size_t` / `usize`），而 C 程序员固执地坚持使用 `int`。要理解其中的原因，考虑下面的 `for` 循环：

```cpp
for (unsigned int i = 0; i < n; i++) {
    // ...
}
```

这样的循环会执行多少次？这里实际上有两个合理的答案：$$n$$ 次或者无限次。执行无限次是因为 $$n$$ 可以超过 $$2^{32}$$。虽然前者更有可能是程序员期望的结果，但是编译器为了遵守语言规范，仍然不得不考虑两种情况，并插入额外的运行时检查，还得做不同的优化。与此同时，编译器认为 `int` 版本将只会进行 $$n$$ 次迭代，因为有符号溢出被定义为不存在。

### 移除边际情况

“安全”的编程风格通常需要进行大量的运行时检查，但这其实不需要牺牲大量性能。

例如，Rust 在使用索引数组和其他随机访问结构时会添加边界检查。在 C++ STL 中，`vector` 和 `array` 有“unsafe” `[]` 操作符和“safe” `.at()` 方法：

```cpp
T at(size_t k) {
    if (k >= size())
        throw std::out_of_range("Array index exceeds its size");
    return _memory[k];
}
```

有趣的是，这些检查实际上在运行时经常不会被运行，因为编译器在编译期可以证明访问一定在边界内部。例如一个从 1 迭代到 `size()` 的 `for` 循环，每一步都会访问第 $$i$$ 个元素，此时不可能发生任何非法的事情，所以边界检查可以安全地优化掉。

### 假设

当编译器不能证明这些边际情况不存在，但你能时。这些附加信息可以使用未定义行为机制来提供。

Clang 中有一个 `__builtin_assume` 函数，你可以在其中放置一个你保证为真的语句，编译器会在优化中使用这个假设。在 GCC 中，你也可以使用 `__builtin_unreachable` 来模仿这个效果：

```cpp
void assume(bool pred) {
    if (!pred)
        __builtin_unreachable();
}
```

例如，你可以在 `at` 之前放置 `assume(k < vector.size())`，然后边界检查就会被优化掉。

将 `assume` 和 `assert` 以及 `static_assert` 结合起来是非常有效的：你可以用同样的函数，在 debug 模式下检查前提条件，而在生产发布模式下用 assume 提升性能。

### 算术

你应该记住一些常见的边际情况，尤其是在优化算法的时候。

对于浮点数运算，就不用那么担心了，因为你可以用 `-ffast-math` 标志来关闭严格地遵从标准（`-Ofast` 选项启用了该标志）。几乎任何情况下你都应该打开这个标志，否则，编译器只能按照与源代码相同的顺序执行算术运算，而不会进行任何优化。

再整数情况下则不适用，因为整数运算总要是精确的。考虑除以 2：

```cpp
unsigned div_unsigned(unsigned x) {
    return x / 2;
}
```

一个常见的优化是将其优化为一个右移操作。但是这只是在所有的正数上才起效，如果是一般情况呢？

```cpp
int div_signed(int x) {
    return x / 2;
}
```

如果 `x` 是负数，那么简单的右移就不再有效，无论右移是补零还是补符号位：

- 如果补零，就会得到一个非负的结果，因为符号位为 0.
- 如果补符号位，那么舍入会变成向负无穷舍入，而不是正常除法的向零舍入。[^1]

因此对于一般情况，不得不多加一些指令：

```nasm
mov  ebx, eax
shr  ebx, 31    ; 提取符号位
add  eax, ebx   ; 如果是负数，将原数增加 1，从而保证可以向 0 舍入
sar  eax        ; 补符号位的右移
```

如果只有正数的情况是我们想要的，我们也可以使用 `assume` 机制来消除 `x` 的可能性，从而避免处理这种极端情况：

```cpp
int div_assume(int x) {
    assume(x >= 0);
    return x / 2;
}
```

（不过在这种特殊情况下，最好的方式还是用无符号数来表达我们只考虑正数情况。）

由于类似这样的细微差别，在中间函数中展开代数表达式并手动简化算术运算而不是完全依赖编译器来完成这些操作通常是有益的。

### 内存别名

编译器在涉及内存读写时的优化相当糟糕，这是因为它们通常没有足够的上下文来进行正确的优化。

```cpp
void add(int *a, int *b, int n) {
    for (int i = 0; i < n; i++)
        a[i] += b[i];
}
```

由于每次的循环都是独立的，因此可以并行和向量化地执行。但这真的对吗？

一个可能性在于 `a` 和 `b` 数组可能是相交的。考虑 `b == a + 1` 的情况。在这种情况下，唯一的正确结果是顺序地运行循环。编译器必须要检查这种可能性，尽管程序员知道这不可能发生。

因此在 C++ 中，我们有 `const` 和 `restrict` 关键字。第一个关键字表明我们不会用指针修改内存变量，第二个则是一种告诉编译器所指向的内存保证不是别名。

```cpp
void add(int * __restrict__ a, const int * __restrict__ b, int n) {
    for (int i = 0; i < n; i++)
        a[i] += b[i];
}
```

这些关键字本身也非常适合用于 _自文档化（self-documenting）_ 的目的。

### C++ 契约

_契约式编程（Contract Programming）_ 是一种未被充分利用但非常强大的技术。

目前有一个后期提案，旨在以 _契约属性（contract attributes）_ 的形式将 _契约式设计（Design-by-Contract）_ 引入 C++ 标准，这些属性在功能上等同于我们手工实现的、编译器特定的 `assume`：

```cpp
T at(size_t k) [[ expects: k < n ]] {
    return _memory[k];
}
```

有三种类型的属性 `expects`，`ensures`，`assert`。分别被用来表达函数的前置、后置条件，以及可以放在程序中任何地方的通用断言。

遗憾的是，这个令人兴奋的新特性还没有被标准化更别说在主流 C++ 编译器实现了（注：C++ 23 标准中加入了 `assume` 属性，也就是可以放在程序中任何地方的通用断言，还加入了 `std::unreachable()` 等东西）。但也许几年后，我们将能够编写这样的代码：

```cpp
bool is_power_of_two(int m) {
    return m > 0 && (m & (m - 1) == 0);
}

int mod_power_of_two(int x, int m)
    [[ expects: x >= 0 ]]
    [[ expects: is_power_of_two(m) ]]
    [[ ensures r: r >= 0 && r < m ]]
{
    int r = x & (m - 1);
    [[ assert: r = x % m ]];
    return r;
}
```

在其他注重性能的语言（如 Rust 和 D 语言）中也可以使用某些形式的契约编程。

一个通用的建议是：始终检查编译器生成的汇编代码，如果结果不符合预期，尝试思考如何限制编译器优化的边界情况。

[^1]: 你知道吗？在 Python 中，对负数进行整数除法时，结果会向下取整，因此 `-5 // 2 = -3`，这等同于 `-5 >> 1 = -3`。原作者怀疑 Guido van Rossum 在设计这门语言时是否考虑到了这种优化。因此从理论上讲，一个包含大量除以二操作的 JIT 编译的 Python 程序可能比类似的 C++ 程序更快。

## 五 - 预先计算（编译期计算）

当编译器能够推断出某个变量不依赖于任何用户提供的数据时，它们可以在编译期间计算其值，并将其作为常量嵌入生成的机器代码中。

这种优化对性能提升有很大帮助，但它并不是 C++ 标准的一部分，因此编译器不必强制实现它。当编译期计算难以实现或耗时较长时，编译器可能会放弃这种优化机会。

### 常量表达式

有一个更可靠的实现方案：在现代 C++ 中，你可以标记一个函数为 `constexpr`。如果它通过传入常数来调用，那么就会在编译期计算出结果：

```cpp
constexpr int fibonacci(int n) {
    if (n <= 2)
        return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

static_assert(fibonacci(10) == 55);
```

这些函数会有一些额外的限制，比如它们只能调用其他 `constexpr` 函数，不能分配内存，但除此之外，它们会“按原样”执行。

注意虽然 `constexpr` 函数在运行时不会有开销，但它们增加了编译时间。所以至少还是稍微关心一下它们的效率，不要在里面整一些 NP 完全的活。比方说上面的斐波那契函数可以修改为：

```cpp
constexpr int fibonacci(int n) {
    int a = 1, b = 1;
    while (n--) {
        int c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```

在早期的 C++ 标准中，曾经存在更多的限制。例如，你不能在编译时计算中使用任何状态，而必须依赖递归。这使得整个过程更像是 Haskell 函数式编程而不是 C++。但从 C++17 开始，我们甚至可以使用命令式的风格来计算静态数组，这对于预计算查找表非常有用：

```cpp
struct Precalc {
    int isqrt[1000];

    constexpr Precalc() : isqrt{} {
        for (int i = 0; i < 1000; i++)
            isqrt[i] = int(sqrt(i));
    }
};

constexpr Precalc P;

static_assert(P.isqrt[42] == 6);
```

另外，当你通过传入非常量来调用 `constexpr` 函数时，编译器可能会也可能不会在编译期计算它们：

```cpp
for (int i = 0; i < 100; i++)
    cout << fibonacci(i) << endl;
```

在这个例子中，尽管从技术上讲我们执行了固定次数的迭代，并使用的是编译期已知的参数调用了 `fibonacci` 函数，但这些参数在技术上并不是编译时常量。是否优化这个循环取决于编译器。而对于复杂的计算，编译器通常选择不优化。
