---
title: 高性能计算-第七章-数论
date: 2025-4-3 12:00:00 +0800
categories: [笔记, 高性能计算]
tags: [高性能计算]     # TAG names should always be lowercase
math: true
---
[原文](https://en.algorithmica.org/hpc/number-theory/)

（嗨嗨嗨，优势区间来了）

## 序 - 数论

在 1940 年，一个英国数学家 G. H. Hardy 出版了一个非常著名的文章《一个数学家的辩白》，讨论了数学应该追求其本身而不是其应用的概念。

和数学一样，计算机科学的各个领域也构成了一个光谱，一边是数理逻辑和计算理论，另一边是网络编程和应用开发。我们假设读者，也就是你，是一个更偏向于应用的计算机科学家。这本书写出来就是为了表明在实际算法设计上的工作比在理论计算机科学上的工作少太多了——既然你读到了第七章，那么你大概率也赞成这个说法。

但是，抛开主观意见不谈，Hardy 的这一观点也有客观因素。在写那篇文章的时候，他已经 62 岁了。他目睹了第一次世界大战和正在进行的第二次世界大战所造成的破坏，而科学在其中造成了更多的破坏。作为一个数论科学家，Hardy 在这种“无用”领域上的工作寻找到了平静，而且不用担心任何道德谴责。

> 到目前为止，还没有人发现数论或相对论可以用于任何军事目的，而且在许多年内，似乎也不太可能有人会这样做。

讽刺的是，随着原子弹的发明，这句话在 5 年后就被证明是错的了。如果没有对相对论的深刻理解，这是不可能达成的。同样的，在数论之上我们也建立起了计算机密码学这一领域——本章的主题便是计算。

## 一 - 模运算

计算机通常使用从 1970.1.1（Unix 时代的开始）后经过的秒数来作为时间戳。

我们人类也会记录与过去某个时间点相关的时间，一般是具有政治或宗教意义的时间点。例如，在撰写本文（指原文）的那一刻，从公元 1 年（公元 6 世纪时东罗马僧侣对耶稣基督出生日期的最佳估计）至今，已经过去大约了 63882260594 秒。

但与电脑不同，我们并不是总是需要所有的信息。考虑到手头上的事情，我们可能会说“现在下午两点了，该吃午饭了。”或者“现在是星期四，v 我 50。”相较于使用整个时间戳，我们更经常使用余数来考虑我们所需要的信息。毕竟处理两位数字比处理十一位数字要简单得多。

**问题**：如果今天是星期四，那么明年的同一个日期是星期几？

我们将一周的日期方式在 $[0,6]$ 中，显然这是一个循环的结构。星期四是数字 $3$，那么明年的同一日期便是 $(3 + 365) \bmod 7 = 4$，也就是星期五。（如果不是闰年的话）

### 余数

**定义**：我们称两个整数 $a$ 和 $b$ 模 $m$ 同余，如果它们的差是 $m$ 的倍数：

$$
m | (a-b) \Leftrightarrow a \equiv b \pmod m
$$

比方说，一年的第 42 天和第 161 天的日期就是相同的，$161 - 42 = 119 = 17 \times 7$.

模 $m$ 同余是一种等价关系，可以将所有整数分成不同的等价类。虽然每一个类都可以使用其中任何一个数字来表示，但我们比较经常使用一个等价类中的最小非负整数来表达这个等价类。

模运算就是在这些等价类上的运算，它是数论的基础。

**问题**：现在，我们定义一“周”有 $m$ 天，一“年”有 $a$ 天。那么考虑每年的相同日期，它们会遍历一周中的所有星期吗？如果不能，它们包含几个不同的星期？

假设今天是周一，那么 $d_0 = 0$，第 $k$ 年的星期即为：

$$
d_k \equiv ka \mod m
$$

原问题实际上就是在找出最小的正整数 $k$，使得

$$
ka \equiv 0 \pmod m
$$

如果 $a$ 和 $m$ 互素，那么 $k$ 只有等于 $m$ 的时候 $ka$ 才会是 $m$ 的倍数。基于这一思路，我们用 $(a,m)$ 表示 $a$ 和 $m$ 的最大公因数，则有：

$$
\frac{ka}{(a,m)} \equiv 0 \pmod{\frac{m}{(a,m)}}
$$

此时 $\frac{a}{(a,m)}$ 和 $\frac{m}{(a,m)}$ 是互素的，因此 $k$ 的取值为 $\frac{m}{(a,m)}$。

### 费马小定理

现在我们考虑如果使用乘法而非加法：

$$
d_n = a^n \mod m
$$

那么序列 $d_i$ 中会有多少不重复的值？

**定理**：对于任何整数 $a$ 和素数 $p$：

$$
a^p \equiv a \pmod p
$$

**证明**：我们用 $P(x_1,x_2,\dots,x_n) = \frac{(\sum_i x_i)!}{\prod (x_i!)}$ 来表示多项式系数（多重组合数），那么：

$$
\begin{aligned}
a^p &= (\underbrace{1+1+\dots+1}_{a \text{ times}})^p \\
&= \sum_{\sum_{i} x_i = p} P(x_1,x_2,\dots,x_a) \\
&= P(p,0,\dots,0) + P(0,p,\dots,0) + \dots + P(0,0,\dots,p) \\
&= a \pmod p
\end{aligned}
$$

其中第三个等式是因为 $p$ 是一个素数，因此任何小于 $p$ 的 $x_i$，其阶乘 $x_i$ 中都不可能包含因子 $p$，所以多重组合数分子上的因子 $p$ 会被保留下来，使得整个多重组合数是 $p$ 的倍数。只有当 $P(p,0,\dots,0)$ 等情况时，因子 $p$ 才会被除掉，得到结果 $1$。

需要注意的是这一定理只对素数 $p$ 成立。反过来，我们可以使用这一定理来检测 $p$ 是否为素数：随机选择一个 $a$，如果 $a^p \mod p$ 不等于 $a$，则 $p$ 一定不是素数。

这被成为 _费马素性检测_，并且是一个概率算法，只会返回“不是素数”和“可能是素数”。我们可以选取不同的 $a$ 直到我们认为犯错的概率足够低。

素性检测可以用来生成大素数（用于密码学）。由于 $n$ 以内大约有 $\frac{n}{\ln n}$ 个素数（并不打算在这里证明），它们的分布基本是均匀的。因此我们可以随便选一个数，然后不断增加并检测是否是素数，这大约需要 $O(\ln n)$ 次素性检测。

费马素性检测的一个非常糟糕的输入是[卡迈克尔数](https://en.wikipedia.org/wiki/Carmichael_number)，它是个费马伪素数，可以完全通过费马素性检测。不过他们非常少见，所以还好。

关于时间复杂性：素性检测实际上是一个 P 问题，对于一个数 $n$，由于输入只需要 $\log n$ 个 bit 来表示，因此 P 算法必须是关于 $n$ 呈现 polylog 的。AKS 素性测试算法便是一个 $O(\log^8 n) 的一个确定性算法。

### 模意义下的除法

在模意义下，加减乘运算都可以比较直接的进行扩展，只要处理好整数溢出和负数即可。

```cpp
c = (a + b) % m;
c = (a - b + m) % m;
c = a * b % m;
```

但是除法没有这个性质：

$$
\frac{8 \mod 5}{2 \mod 5} = \frac{3}{2} \neq 4
$$

在模意义下，我们会使用乘以逆元的方式来做除法，而逆元即为：

$$
a^p \equiv a \Rightarrow a^{p-2} \equiv a^{-1} \pmod p
$$

因此，$a^{p-2}$ 就是 $a$ 的逆元。

## 二 - 二进制快速幂

在模运算中，经常需要求一个数的 $n$ 次幂。快速幂可以在 $O(\log n)$ 的时间内计算一个 $n$ 次幂。它只基于以下两个公式：

$$
a^{2k} = (a^{k})^2 \\
a^{2k + 1} = (a^{k})^2 \cdot a
$$

为了计算 $a^n$，可以递归计算 $a^{\lfloor n / 2\rfloor}$：

$$
a^n = f(a,n) = \left\{
\begin{aligned}
& 1, & n=0 \\
&f(a,\frac{n}{2})^2, & 2 \mid n \\
&f(a,n-1)\cdot a, & 2 \nmid n
\end{aligned}
\right.
$$

由于算法每两次递归都会至少减半，因此算法的深度和乘法的次数都是 $O(\log n)$ 的。

### 递归实现

```rust
pub fn binpow_rec<const M:u64>(base: u64, exp: u64) -> u64 {
    match exp {
        0 => 1,
        _ if exp % 2 == 0 => {
            let half = binpow_rec::<M>(base, exp / 2);
            (half * half) % M
        }
        _ => (base % M * binpow_rec::<M>(base, exp - 1)) % M,
    }
}
```

在算法竞赛中，$M$ 一般会被设置为 $10^9 + 7$。因为它是一个素数（因此所有非零元素都有逆元）、足够大、进行一次加法时不会超出 `int`、进行一次乘法时不会超出 `long long`，并且还可以通过 `1e9 + 7` 来快速输入。

一般我们会将 $M$ 设置为编译期常数，这样编译器会将取模运算优化成一个乘法和一个移位操作（详见第六章第七节）。即使没办法在编译期得到模 $M$ 时的相关魔法数字，我们也可以手动计算一次它们，然后快速进行除法或取模运算。

baseline 执行 $2^{10^9} \mod (10^9 + 7)$ 大约需要 300ns。在这里递归调用产生了一些额外的开销。

### 迭代实现

$a^n$ 可以被表示成某些 $a$ 的 $2^i$ 次幂的乘积，只需要将 $n$ 看作是 2 进制就可以很容易的展开，例如：

$$
a^{42} = a^{32 + 8 + 2} = a^{32}a^{8}a^{2}
$$

```rust
pub fn binpow_iter<const M:u64>(mut base: u64, mut exp: u64) -> u64 {
    base %= M;
    let mut result = 1;

    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % M;
        }
        base = (base * base) % M;
        exp /= 2;
    }
    result
}
```

该算法执行 $2^{10^9} \mod (10^9 + 7)$ 大约需要 100ns。如果 $M$ 不是编译期常数，我也写了一份非编译期的 `binpow` （Lemire Reduction），但这份代码只需要 80ns。可能是由于采用的是自然溢出的方式，少了一次移位操作。

如果 `exp` 是一个常数（例如求逆元时，`exp` 总是 $M-2$），虽然理论上编译器可以优化，但是 while 循环往往会阻止编译器优化。我们可以将其重写为 `for` 循环，以促使编译器进行优化。
